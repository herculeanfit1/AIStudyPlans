name: Simple Secure Backup

on:
  schedule:
    # Run at 9AM Central (14:00-15:00 UTC) and 9PM Central (02:00-03:00 UTC)
    - cron: '0 14 * * *'
    - cron: '0 2 * * *'
  # Allow manual triggering
  workflow_dispatch:

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      - name: Configure Git
        shell: bash
        run: |
          # Ensure Git is properly initialized with safe directories and no extraheader
          git config --global --add safe.directory '*'
          git config --global core.longpaths true
          
          # First check if the extraheader exists before trying to remove it
          if git config --global --get http.https://github.com/.extraheader > /dev/null 2>&1; then
            echo "Removing existing extraheader..."
            git config --global --unset-all http.https://github.com/.extraheader
          else
            echo "No extraheader found to remove"
          fi
          
          # Display current git config for debugging
          echo "Current Git configuration:"
          git config --global --list
      
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup GPG
        id: setup_gpg
        run: |
          # Debug step to check if secrets exist (without revealing their values)
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.GPG_RECIPIENT }}" ]; then
            echo "Error: GPG_RECIPIENT secret is not set"
            exit 1
          fi
          
          # Create a temporary file with the GPG key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > /tmp/private.key 2>/dev/null || {
            echo "${{ secrets.GPG_PRIVATE_KEY }}" > /tmp/private.key
          }
          
          # Check if the key file has content
          key_size=$(wc -c < /tmp/private.key)
          echo "Key file size: $key_size bytes"
          if [ ! -s /tmp/private.key ]; then
            echo "Error: GPG private key file is empty"
            exit 1
          fi
          
          # Import the key
          echo "Importing GPG key..."
          gpg --batch --import /tmp/private.key || {
            echo "Error: Failed to import GPG key"
            echo "Key file stats:"
            wc -l /tmp/private.key
            file /tmp/private.key
            exit 1
          }
          
          # Clean up
          rm /tmp/private.key
          
          # Verify GPG is working properly
          echo "Verifying GPG recipient: ${{ secrets.GPG_RECIPIENT }}"
          gpg --list-keys || echo "No keys found in keyring"
          gpg --list-keys "${{ secrets.GPG_RECIPIENT }}" || {
            echo "Error: GPG recipient key not found after import"
            echo "Available keys:"
            gpg --list-keys
            exit 1
          }
      
      - name: Create Backup
        run: |
          # Generate timestamp for backup identification
          TIMESTAMP=$(date +%Y-%m-%d-%H%M%S)
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          
          # Create a clean directory for the backup contents
          echo "Creating backup directory..."
          mkdir -p backup-content
          
          # Create a file list excluding problematic directories
          echo "Creating file list..."
          find . -type f \
            -not -path "*/node_modules/*" \
            -not -path "*/.git/*" \
            -not -path "*/.next/*" \
            -not -path "*/backup-content/*" \
            > backup-files.txt
          
          # Copy files to the backup directory while preserving structure
          echo "Copying files to backup directory..."
          cat backup-files.txt | while read file; do
            # Create target directory
            dir=$(dirname "$file")
            mkdir -p "backup-content/$dir"
            # Copy file
            cp "$file" "backup-content/$file"
          done
          
          # Create archive from the clean directory
          echo "Creating backup archive..."
          tar -czf backup-$TIMESTAMP.tar.gz -C backup-content . || {
            echo "Error: Failed to create tar archive"
            exit 1
          }
          
          # Check archive was created successfully
          archive_size=$(wc -c < backup-$TIMESTAMP.tar.gz)
          echo "Archive size: $archive_size bytes"
          
          # Encrypt the backup - fail if encryption fails
          echo "Encrypting backup with GPG..."
          gpg --batch --yes --trust-model always --encrypt --recipient "${{ secrets.GPG_RECIPIENT }}" backup-$TIMESTAMP.tar.gz || {
            echo "Error: GPG encryption failed"
            exit 1
          }
          
          # Remove unencrypted backup and temp files
          rm backup-$TIMESTAMP.tar.gz
          rm -rf backup-content
          rm backup-files.txt
          echo "BACKUP_FILE=backup-$TIMESTAMP.tar.gz.gpg" >> $GITHUB_ENV
          echo "Backup encrypted successfully"
          
          # Move the backup to a clearly named file for the artifact
          cp backup-$TIMESTAMP.tar.gz.gpg aistudyplans-backup-$TIMESTAMP.tar.gz.gpg
      
      - name: Upload Backup as Artifact
        uses: actions/upload-artifact@v3
        with:
          name: aistudyplans-backup-${{ env.TIMESTAMP }}
          path: aistudyplans-backup-${{ env.TIMESTAMP }}.tar.gz.gpg
          retention-days: 90
      
      - name: Cleanup
        run: |
          rm -f backup-${{ env.TIMESTAMP }}.tar.gz.gpg
          rm -f aistudyplans-backup-${{ env.TIMESTAMP }}.tar.gz.gpg
      
      - name: Summary
        run: |
          echo "Backup completed successfully"
          echo "Backup timestamp: ${{ env.TIMESTAMP }}"
          echo "Backup is available for download as a workflow artifact"
          echo "Artifact name: aistudyplans-backup-${{ env.TIMESTAMP }}" 
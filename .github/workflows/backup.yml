name: Secure Backup

# Update: Added test mode option and enhanced error reporting 
on:
  schedule:
    # Run at 9AM Central (14:00-15:00 UTC) and 9PM Central (02:00-03:00 UTC)
    - cron: '0 14 * * *'
    - cron: '0 2 * * *'
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test mode (only verify GPG)'
        required: false
        default: false
        type: boolean

env:
  BACKUP_REPO: "herculeanfit1/AIStudyPlans-Backups"

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      - name: Set debug mode
        run: |
          echo "DEBUG_ENABLED=true" >> $GITHUB_ENV
          echo "Starting backup job in debug mode"
      
      # Configure Git properly to avoid common issues
      - name: Configure Git
        shell: bash
        run: |
          echo "::group::Git Configuration"
          # Ensure Git is properly initialized with safe directories and no extraheader
          git config --global --add safe.directory '*'
          git config --global core.longpaths true
          
          # First check if the extraheader exists before trying to remove it
          if git config --global --get http.https://github.com/.extraheader > /dev/null 2>&1; then
            echo "Removing existing extraheader..."
            git config --global --unset-all http.https://github.com/.extraheader
          else
            echo "No extraheader found to remove"
          fi
          
          # Display current git config for debugging
          echo "Current Git configuration:"
          git config --global --list
          echo "::endgroup::"
      
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Debug environment
        run: |
          echo "::group::Environment Info"
          echo "OS: $(uname -a)"
          echo "Working directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          echo "GPG version:"
          gpg --version
          echo "::endgroup::"
      
      - name: Setup GPG
        id: setup_gpg
        run: |
          echo "::group::GPG Setup"
          # Debug step to check if secrets exist (without revealing their values)
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.GPG_RECIPIENT }}" ]; then
            echo "Error: GPG_RECIPIENT secret is not set"
            exit 1
          fi
          
          # Check GPG version and installation
          gpg --version
          
          # Create a temporary file with the GPG key
          echo "Attempting to decode GPG key from base64..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > /tmp/private.key 2>/dev/null || {
            echo "Base64 decoding failed, trying raw import..."
            echo "${{ secrets.GPG_PRIVATE_KEY }}" > /tmp/private.key
          }
          
          # Check if the key file has content
          key_size=$(wc -c < /tmp/private.key)
          echo "Key file size: $key_size bytes"
          if [ ! -s /tmp/private.key ]; then
            echo "Error: GPG private key file is empty"
            exit 1
          fi
          
          # Check key file format
          head -n 1 /tmp/private.key | grep -q "BEGIN PGP PRIVATE KEY BLOCK" || {
            echo "Warning: Key file doesn't start with PGP header. First few characters:"
            head -c 20 /tmp/private.key | hexdump -C
          }
          
          # Import the key
          echo "Importing GPG key..."
          gpg --batch --import /tmp/private.key || {
            echo "Error: Failed to import GPG key"
            echo "Key file stats:"
            wc -l /tmp/private.key
            file /tmp/private.key
            exit 1
          }
          
          # Clean up
          rm /tmp/private.key
          
          # Verify GPG is working properly
          echo "Verifying GPG recipient: ${{ secrets.GPG_RECIPIENT }}"
          gpg --list-keys || echo "No keys found in keyring"
          gpg --list-keys "${{ secrets.GPG_RECIPIENT }}" || {
            echo "Error: GPG recipient key not found after import"
            echo "Available keys:"
            gpg --list-keys
            exit 1
          }
          
          # If in test mode, show all available keys
          if [ "${{ github.event.inputs.test_mode }}" == "true" ]; then
            echo "TEST MODE: Showing all available GPG keys"
            gpg --list-keys
          fi
          echo "::endgroup::"
      
      # Skip the rest of the workflow if in test mode
      - name: Test Mode Check
        id: test_mode_check
        if: ${{ github.event.inputs.test_mode == 'true' }}
        run: |
          echo "TEST MODE: GPG setup successful!"
          echo "Workflow would proceed with backup creation and encryption"
          exit 0
      
      - name: Create Backup
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          echo "::group::Backup Creation"
          # Generate timestamp for backup identification
          TIMESTAMP=$(date +%Y-%m-%d-%H%M%S)
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          
          # Create a clean directory for the backup contents
          echo "Creating backup directory..."
          mkdir -p backup-content
          
          # Create a file list excluding problematic directories
          echo "Creating file list..."
          find . -type f \
            -not -path "*/node_modules/*" \
            -not -path "*/.git/*" \
            -not -path "*/.next/*" \
            -not -path "*/backup-content/*" \
            > backup-files.txt
          
          # Copy files to the backup directory while preserving structure
          echo "Copying files to backup directory..."
          cat backup-files.txt | while read file; do
            # Create target directory
            dir=$(dirname "$file")
            mkdir -p "backup-content/$dir"
            # Copy file
            cp "$file" "backup-content/$file"
          done
          
          # Create archive from the clean directory
          echo "Creating backup archive..."
          tar -czf backup-$TIMESTAMP.tar.gz -C backup-content . || {
            echo "Error: Failed to create tar archive"
            exit 1
          }
          
          # Check archive was created successfully
          archive_size=$(wc -c < backup-$TIMESTAMP.tar.gz)
          echo "Archive size: $archive_size bytes"
          echo "Archive file details:"
          ls -la backup-$TIMESTAMP.tar.gz
          
          # List GPG keys before encryption
          echo "Available GPG keys for encryption:"
          gpg --list-keys
          
          # Encrypt the backup - fail if encryption fails
          echo "Encrypting backup with GPG..."
          echo "Using recipient: ${{ secrets.GPG_RECIPIENT }}"
          gpg --batch --yes --verbose --trust-model always --encrypt --recipient "${{ secrets.GPG_RECIPIENT }}" backup-$TIMESTAMP.tar.gz || {
            echo "Error: GPG encryption failed"
            echo "Debugging recipient:"
            gpg --list-keys "${{ secrets.GPG_RECIPIENT }}" || echo "Recipient not found"
            echo "Available keys:"
            gpg --list-keys
            exit 1
          }
          
          # Remove unencrypted backup and temp files
          rm backup-$TIMESTAMP.tar.gz
          rm -rf backup-content
          rm backup-files.txt
          echo "BACKUP_FILE=backup-$TIMESTAMP.tar.gz.gpg" >> $GITHUB_ENV
          echo "Backup encrypted successfully"
          echo "::endgroup::"
      
      - name: Verify Backup Integrity
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          echo "::group::Backup Verification"
          # List the backup file to verify it exists
          ls -la ${{ env.BACKUP_FILE }}
          
          # Check file size to ensure it's not empty (using GNU stat syntax for Ubuntu)
          if [ $(stat -c %s ${{ env.BACKUP_FILE }}) -lt 1000 ]; then
            echo "Error: Backup file too small, backup may have failed"
            exit 1
          fi
          echo "Backup file verification completed successfully"
          echo "::endgroup::"
      
      - name: Push to Backup Repository
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          echo "::group::Backup Repository Push"
          # Check if backup token is set
          if [ -z "${{ secrets.BACKUP_TOKEN }}" ]; then
            echo "Error: BACKUP_TOKEN secret is not set"
            exit 1
          fi
          
          # Setup Git with token authentication - more reliable method
          git config --global user.email "backup@aistudyplans.com"
          git config --global user.name "Backup System"
          
          # Test GitHub token access (without revealing token)
          echo "Testing GitHub token access..."
          AUTH_TEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ secrets.BACKUP_TOKEN }}" https://api.github.com/user)
          if [ "$AUTH_TEST" != "200" ]; then
            echo "Error: GitHub token authentication failed with status code $AUTH_TEST"
            echo "Please check that your token has the correct permissions and is still valid"
            exit 1
          fi
          echo "GitHub token authentication successful"
          
          # Define the backup repository name
          REPO_NAME="${{ github.repository_owner }}/AIStudyPlans-Backups"
          echo "Using backup repository: $REPO_NAME"
          
          # Check if backup repository exists
          echo "Checking backup repository exists: $REPO_NAME"
          REPO_TEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ secrets.BACKUP_TOKEN }}" https://api.github.com/repos/$REPO_NAME)
          echo "Repository check result: $REPO_TEST"
          
          # Clone backup repository (or create if it doesn't exist)
          echo "Cloning backup repository..."
          if ! git clone https://${{ secrets.BACKUP_TOKEN }}@github.com/$REPO_NAME.git backup-repo 2>/dev/null; then
            if [ "$REPO_TEST" = "404" ]; then
              echo "Creating new backup repository..."
              # Create the repository via API
              CREATE_RESPONSE=$(curl -s -X POST -H "Authorization: token ${{ secrets.BACKUP_TOKEN }}" \
                -d "{\"name\":\"AIStudyPlans-Backups\", \"private\":true, \"auto_init\": true}" \
                https://api.github.com/user/repos)
              
              if ! echo "$CREATE_RESPONSE" | grep -q "name"; then
                echo "Error: Failed to create backup repository"
                echo "API Response: $CREATE_RESPONSE"
                exit 1
              fi
              
              echo "Repository creation response received, cloning the new repository"
              git clone https://${{ secrets.BACKUP_TOKEN }}@github.com/$REPO_NAME.git backup-repo
              if [ $? -ne 0 ]; then
                echo "Error: Failed to clone newly created repository"
                exit 1
              fi
            else
              echo "Error: Failed to clone repository and repository exists (HTTP $REPO_TEST)"
              echo "Please check permissions on the repository"
              exit 1
            fi
          fi
          
          # Create backup branch
          cd backup-repo
          echo "Creating backup branch: backup-${{ env.TIMESTAMP }}"
          git checkout -b backup-${{ env.TIMESTAMP }}
          
          # Copy the backup file
          echo "Copying backup file..."
          cp ../${{ env.BACKUP_FILE }} . || {
            echo "Error: Failed to copy backup file"
            ls -la ../${{ env.BACKUP_FILE }}
            exit 1
          }
          
          # Update log
          echo "Backup created: $(date)" >> backup_log.txt
          
          # Commit and push
          echo "Committing and pushing backup..."
          git add ${{ env.BACKUP_FILE }} backup_log.txt
          git commit -m "Backup: ${{ env.TIMESTAMP }}"
          if ! git push origin backup-${{ env.TIMESTAMP }}; then
            echo "Error: Failed to push backup to repository"
            echo "Git push output with tracing:"
            GIT_TRACE=1 git push origin backup-${{ env.TIMESTAMP }}
            exit 1
          fi
          
          echo "Backup successfully pushed to repository"
          echo "::endgroup::"
      
      - name: Cleanup Old Backups
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          echo "::group::Cleanup Old Backups"
          cd backup-repo
          
          # Get list of backup branches
          git fetch origin
          BRANCHES=$(git branch -r | grep origin/backup- | sed 's/origin\///')
          echo "Found branches: $BRANCHES"
          
          # Get 30 days ago date in seconds
          CUTOFF_DATE=$(date -d "30 days ago" +%s)
          echo "Cutoff date: $(date -d @$CUTOFF_DATE)"
          
          # Check each branch and delete if older than cutoff
          for BRANCH in $BRANCHES; do
            echo "Processing branch: $BRANCH"
            # Extract date from branch name (format: backup-YYYY-MM-DD-HHMMSS)
            BRANCH_DATE=$(echo $BRANCH | sed -E 's/backup-([0-9]{4}-[0-9]{2}-[0-9]{2}).*/\1/')
            
            if [ -n "$BRANCH_DATE" ]; then
              echo "  Branch date: $BRANCH_DATE"
              # Convert to seconds - ensure compatibility with Ubuntu runner
              BRANCH_SECONDS=$(date -d "$BRANCH_DATE" +%s 2>/dev/null || echo 0)
              
              if [ $BRANCH_SECONDS -lt $CUTOFF_DATE ] && [ $BRANCH_SECONDS -gt 0 ]; then
                echo "Deleting old backup branch: $BRANCH"
                git push origin --delete $BRANCH
              else
                echo "  Branch is within retention period, keeping it"
              fi
            else
              echo "  Could not extract date from branch name: $BRANCH"
            fi
          done
          echo "::endgroup::"

      - name: Summary
        if: always()
        run: |
          echo "::group::Backup Summary"
          echo "Backup job completed with final status: $?"
          if [ "${{ github.event.inputs.test_mode }}" == "true" ]; then
            echo "Test mode was enabled - only verified GPG setup"
          else
            if [ -n "${{ env.BACKUP_FILE }}" ]; then
              echo "Created backup file: ${{ env.BACKUP_FILE }}"
              echo "Timestamp: ${{ env.TIMESTAMP }}"
            else
              echo "No backup file was created"
            fi
          fi
          echo "::endgroup::"

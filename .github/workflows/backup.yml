name: Secure Backup

# Update: Added test mode option and enhanced error reporting 
on:
  schedule:
    # Run at 9AM Central (14:00-15:00 UTC) and 9PM Central (02:00-03:00 UTC)
    - cron: '0 14 * * *'
    - cron: '0 2 * * *'
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test mode (only verify GPG)'
        required: false
        default: false
        type: boolean

env:
  BACKUP_REPO: "herculeanfit1/AIStudyPlans-Backups"

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      # Configure Git properly to avoid common issues
      - name: Configure Git
        shell: bash
        run: |
          # Ensure Git is properly initialized with safe directories and no extraheader
          git config --global --add safe.directory '*'
          git config --global core.longpaths true
          
          # First check if the extraheader exists before trying to remove it
          if git config --global --get http.https://github.com/.extraheader > /dev/null 2>&1; then
            echo "Removing existing extraheader..."
            git config --global --unset-all http.https://github.com/.extraheader
          else
            echo "No extraheader found to remove"
          fi
          
          # Display current git config for debugging
          echo "Current Git configuration:"
          git config --global --list
      
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup GPG
        id: setup_gpg
        run: |
          # Debug step to check if secrets exist (without revealing their values)
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "Error: GPG_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          if [ -z "${{ secrets.GPG_RECIPIENT }}" ]; then
            echo "Error: GPG_RECIPIENT secret is not set"
            exit 1
          fi
          
          # Check GPG version and installation
          gpg --version
          
          # Create a temporary file with the GPG key
          echo "Attempting to decode GPG key from base64..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | base64 -d > /tmp/private.key 2>/dev/null || {
            echo "Base64 decoding failed, trying raw import..."
            echo "${{ secrets.GPG_PRIVATE_KEY }}" > /tmp/private.key
          }
          
          # Check if the key file has content
          key_size=$(wc -c < /tmp/private.key)
          echo "Key file size: $key_size bytes"
          if [ ! -s /tmp/private.key ]; then
            echo "Error: GPG private key file is empty"
            exit 1
          fi
          
          # Check key file format
          head -n 1 /tmp/private.key | grep -q "BEGIN PGP PRIVATE KEY BLOCK" || {
            echo "Warning: Key file doesn't start with PGP header. First few characters:"
            head -c 20 /tmp/private.key | hexdump -C
          }
          
          # Import the key
          echo "Importing GPG key..."
          gpg --batch --import /tmp/private.key || {
            echo "Error: Failed to import GPG key"
            echo "Key file stats:"
            wc -l /tmp/private.key
            file /tmp/private.key
            exit 1
          }
          
          # Clean up
          rm /tmp/private.key
          
          # Verify GPG is working properly
          echo "Verifying GPG recipient: ${{ secrets.GPG_RECIPIENT }}"
          gpg --list-keys || echo "No keys found in keyring"
          gpg --list-keys "${{ secrets.GPG_RECIPIENT }}" || {
            echo "Error: GPG recipient key not found after import"
            echo "Available keys:"
            gpg --list-keys
            exit 1
          }
          
          # If in test mode, show all available keys
          if [ "${{ github.event.inputs.test_mode }}" == "true" ]; then
            echo "TEST MODE: Showing all available GPG keys"
            gpg --list-keys
          fi
      
      # Skip the rest of the workflow if in test mode
      - name: Test Mode Check
        id: test_mode_check
        if: ${{ github.event.inputs.test_mode == 'true' }}
        run: |
          echo "TEST MODE: GPG setup successful!"
          echo "Workflow would proceed with backup creation and encryption"
          exit 0
      
      - name: Create Backup
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          # Generate timestamp for backup identification
          TIMESTAMP=$(date +%Y-%m-%d-%H%M%S)
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          
          # Create archive of project files
          echo "Creating backup archive..."
          tar -czf backup-$TIMESTAMP.tar.gz . || {
            echo "Error: Failed to create tar archive"
            exit 1
          }
          
          # Check archive was created successfully
          archive_size=$(wc -c < backup-$TIMESTAMP.tar.gz)
          echo "Archive size: $archive_size bytes"
          
          # List GPG keys again before encryption
          echo "Available GPG keys for encryption:"
          gpg --list-keys
          
          # Encrypt the backup - fail if encryption fails
          echo "Encrypting backup with GPG..."
          echo "Using recipient: ${{ secrets.GPG_RECIPIENT }}"
          gpg --batch --yes --verbose --trust-model always --encrypt --recipient "${{ secrets.GPG_RECIPIENT }}" backup-$TIMESTAMP.tar.gz || {
            echo "Error: GPG encryption failed"
            echo "Debugging recipient:"
            gpg --list-keys "${{ secrets.GPG_RECIPIENT }}" || echo "Recipient not found"
            echo "Available keys:"
            gpg --list-keys
            exit 1
          }
          
          # Remove unencrypted backup
          rm backup-$TIMESTAMP.tar.gz
          echo "BACKUP_FILE=backup-$TIMESTAMP.tar.gz.gpg" >> $GITHUB_ENV
          echo "Backup encrypted successfully"
      
      - name: Verify Backup Integrity
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          # List the backup file to verify it exists
          ls -la ${{ env.BACKUP_FILE }}
          
          # Check file size to ensure it's not empty (using GNU stat syntax for Ubuntu)
          if [ $(stat -c %s ${{ env.BACKUP_FILE }}) -lt 1000 ]; then
            echo "Error: Backup file too small, backup may have failed"
            exit 1
          fi
      
      - name: Push to Backup Repository
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          # Check if backup token is set
          if [ -z "${{ secrets.BACKUP_TOKEN }}" ]; then
            echo "Error: BACKUP_TOKEN secret is not set"
            exit 1
          fi
          
          # Setup Git with token authentication - more reliable method
          git config --global user.email "backup@aistudyplans.com"
          git config --global user.name "Backup System"
          
          # Test GitHub token access (without revealing token)
          echo "Testing GitHub token access..."
          AUTH_TEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ secrets.BACKUP_TOKEN }}" https://api.github.com/user)
          if [ "$AUTH_TEST" != "200" ]; then
            echo "Error: GitHub token authentication failed with status code $AUTH_TEST"
            echo "Please check that your token has the correct permissions and is still valid"
            exit 1
          fi
          echo "GitHub token authentication successful"
          
          # Check if backup repository exists
          echo "Checking backup repository exists: ${{ env.BACKUP_REPO }}"
          REPO_TEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ secrets.BACKUP_TOKEN }}" https://api.github.com/repos/${{ env.BACKUP_REPO }})
          echo "Repository check result: $REPO_TEST"
          
          # Clone backup repository (or create if it doesn't exist)
          echo "Cloning backup repository..."
          if ! git clone https://${{ secrets.BACKUP_TOKEN }}@github.com/${{ env.BACKUP_REPO }}.git backup-repo 2>/dev/null; then
            if [ "$REPO_TEST" = "404" ]; then
              echo "Creating new backup repository..."
              # Create the repository via API
              curl -X POST -H "Authorization: token ${{ secrets.BACKUP_TOKEN }}" \
                -d '{"name":"AIStudyPlans-Backups", "private":true}' \
                https://api.github.com/user/repos
              
              # Now set up the local repo
              mkdir -p backup-repo
              cd backup-repo
              git init
              git remote add origin https://${{ secrets.BACKUP_TOKEN }}@github.com/${{ env.BACKUP_REPO }}.git
              git branch -M main
              echo "# AIStudyPlans Backup Repository" > README.md
              git add README.md
              git commit -m "Initial commit"
              if ! git push -u origin main; then
                echo "Error: Failed to push initial commit to backup repository"
                echo "Git push output:"
                GIT_TRACE=1 git push -u origin main
                exit 1
              fi
              cd ..
            else
              echo "Error: Failed to clone repository and repository exists (HTTP $REPO_TEST)"
              echo "Please check permissions on the repository"
              exit 1
            fi
          fi
          
          # Create backup branch
          cd backup-repo
          echo "Creating backup branch: backup-${{ env.TIMESTAMP }}"
          git checkout -b backup-${{ env.TIMESTAMP }}
          
          # Copy the backup file
          echo "Copying backup file..."
          cp ../${{ env.BACKUP_FILE }} . || {
            echo "Error: Failed to copy backup file"
            ls -la ../${{ env.BACKUP_FILE }}
            exit 1
          }
          
          # Update log
          echo "Backup created: $(date)" >> backup_log.txt
          
          # Commit and push
          echo "Committing and pushing backup..."
          git add ${{ env.BACKUP_FILE }} backup_log.txt
          git commit -m "Backup: ${{ env.TIMESTAMP }}"
          if ! git push origin backup-${{ env.TIMESTAMP }}; then
            echo "Error: Failed to push backup to repository"
            echo "Git push output with tracing:"
            GIT_TRACE=1 git push origin backup-${{ env.TIMESTAMP }}
            exit 1
          fi
          
          echo "Backup successfully pushed to repository"
      
      - name: Cleanup Old Backups
        if: ${{ github.event.inputs.test_mode != 'true' }}
        run: |
          cd backup-repo
          
          # Get list of backup branches
          git fetch origin
          BRANCHES=$(git branch -r | grep origin/backup- | sed 's/origin\///')
          
          # Get 30 days ago date in seconds
          CUTOFF_DATE=$(date -d "30 days ago" +%s)
          
          # Check each branch and delete if older than cutoff
          for BRANCH in $BRANCHES; do
            # Extract date from branch name (format: backup-YYYY-MM-DD-HHMMSS)
            BRANCH_DATE=$(echo $BRANCH | sed -E 's/backup-([0-9]{4}-[0-9]{2}-[0-9]{2}).*/\1/')
            
            if [ -n "$BRANCH_DATE" ]; then
              # Convert to seconds - ensure compatibility with Ubuntu runner
              BRANCH_SECONDS=$(date -d "$BRANCH_DATE" +%s 2>/dev/null || echo 0)
              
              if [ $BRANCH_SECONDS -lt $CUTOFF_DATE ] && [ $BRANCH_SECONDS -gt 0 ]; then
                echo "Deleting old backup branch: $BRANCH"
                git push origin --delete $BRANCH
              fi
            fi
          done 
